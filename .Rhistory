import itertools
import networkx as nx
import plotly.graph_objects as go
import numpy as np
from typing import List, Tuple
import plotly.subplots as sp
from plotly.subplots import make_subplots
from functions import create_random_schedules, calculate_objective, compute_convolutions, local_search, get_v_star, powerset, get_neighborhood, build_welch_bailey_schedule, service_time_with_no_shows, create_schedule_network, create_schedule_network_var_edges, create_schedule_network_from_lists, local_search_w_intermediates
# Parameters
N = range(10, 13)
T = 15
s = [0.3, 0.2, 0.1, 0.05, 0.15, 0.2]  # Example service time probability distribution
d = 2  # Duration threshold
q = 0.1  # No-show probability
w = 0.9  # Weight for waiting time in the objective
v_star = get_v_star(T)
# Lists to store results
x_stars = []
x_initials = []  # To store initial schedules
obj_vals = []
schedules_list, objectives_list = [], []
# Iterate over each n in N
for n in N:
print(f'Running local search for schedule with N={n}')
x = build_welch_bailey_schedule(n, T)
x_initials.append(x)  # Store the initial schedule
convolutions = compute_convolutions(s, n, q)
schedules, objectives = local_search_w_intermediates(x, d, q, convolutions, w, v_star, T)
#x_star, obj = local_search(x, d, q, convolutions, w, v_star, T)
obj_vals.append(objectives[-1])
x_stars.append(schedules[-1])
schedules_list.append(schedules)
objectives_list.append(objectives)
print("Optimized Schedules:", x_stars)
print("Objective Values:", obj_vals)
for idx, (n, schedules, objectives) in enumerate(zip(N, schedules_list, objectives_list), start=1):
print(f'Processing N={n}')
# Create individual network graph
individual_fig = create_schedule_network_from_lists(
schedules=schedules,
objective_values=objectives,
echo=False
)
# Show the individual network graph
individual_fig.show()
reticulate::repl_python()
reticulate::repl_python()
