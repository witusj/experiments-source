<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="AI generated">

<title>Tutorial Fast Fourier Transformations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="tut-fft_files/libs/clipboard/clipboard.min.js"></script>
<script src="tut-fft_files/libs/quarto-html/quarto.js"></script>
<script src="tut-fft_files/libs/quarto-html/popper.min.js"></script>
<script src="tut-fft_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="tut-fft_files/libs/quarto-html/anchor.min.js"></script>
<link href="tut-fft_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="tut-fft_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="tut-fft_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="tut-fft_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="tut-fft_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script type="text/javascript">
window.PlotlyConfig = {MathJaxConfig: 'local'};
if (window.MathJax && window.MathJax.Hub && window.MathJax.Hub.Config) {window.MathJax.Hub.Config({SVG: {font: "STIX-Web"}});}
if (typeof require !== 'undefined') {
require.undef("plotly");
requirejs.config({
    paths: {
        'plotly': ['https://cdn.plot.ly/plotly-2.32.0.min']
    }
});
require(['plotly'], function(Plotly) {
    window._Plotly = Plotly;
});
}
</script>


  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tutorial Fast Fourier Transformations</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>AI generated </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Below is a comprehensive tutorial on using FFT to work with probability distributions—specifically for computing convolutions of probability mass functions (PMFs). This technique is very useful when you want to determine the distribution of the sum of independent random variables.</p>
<hr>
<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<p>When you have two independent discrete random variables with PMFs (f) and (g), the probability distribution of their sum is given by the convolution:</p>
<p><span class="math display">\[
(f * g)[n] = \sum_{k} f[k] \, g[n - k]
\]</span></p>
<p>For example, if you have a PMF representing the waiting time for a service, convolving that PMF with itself gives you the distribution of the total waiting time for two independent services. Direct convolution can be computationally expensive for long distributions, but using the Fast Fourier Transform (FFT) can accelerate this process.</p>
<hr>
</section>
<section id="fft-and-convolution" class="level1">
<h1>2. FFT and Convolution</h1>
<p>The <strong>Convolution Theorem</strong> states that the Fourier transform of a convolution is the pointwise product of the Fourier transforms. In other words:</p>
<p><span class="math display">\[
\mathcal{F}(f * g) = \mathcal{F}(f) \cdot \mathcal{F}(g)
\]</span></p>
<p>This means that instead of summing over products (which is (O(n^2)) for two sequences of length (n)), we can:</p>
<ol type="1">
<li><strong>Transform both PMFs into the frequency domain using FFT:</strong><br>
When you apply the FFT to a PMF, you convert it from the time (or probability) domain into the frequency domain. The resulting complex numbers represent the amplitude and phase of the frequency components that make up the original PMF.</li>
</ol>
<div id="0ffcb08e" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.graph_objects <span class="im">as</span> go</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> plotly.io <span class="im">as</span> pio</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a sample PMF (Probability Mass Function)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.25</span>, <span class="fl">0.15</span>])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Original PMF:"</span>, pmf)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- Step 1: Transform the PMF into the Frequency Domain using FFT ----</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Applying FFT converts the PMF from the time (probability) domain into the frequency domain.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># The result is an array of complex numbers where each element represents a frequency component.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>fft_result <span class="op">=</span> np.fft.rfft(pmf)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"FFT Result:"</span>, fft_result)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- Step 2: Extract Amplitude and Phase ----</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># The amplitude (or magnitude) of each complex number tells you the contribution (strength) of that frequency component.</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>amplitude <span class="op">=</span> np.<span class="bu">abs</span>(fft_result)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># The phase indicates the shift (in radians) of the corresponding frequency component.</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>phase <span class="op">=</span> np.angle(fft_result)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Amplitude:"</span>, amplitude)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Phase:"</span>, phase)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># ---- Step 3: Visualize the Frequency Domain Representation ----</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co"># We create an interactive Plotly figure to display both the amplitude and phase spectra.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure()</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Amplitude Spectrum</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>fig.add_trace(go.Scatter(</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>np.arange(<span class="bu">len</span>(amplitude)),</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>amplitude,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">'markers+lines'</span>,</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    name<span class="op">=</span><span class="st">'Amplitude Spectrum'</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot Phase Spectrum</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>fig.add_trace(go.Scatter(</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span>np.arange(<span class="bu">len</span>(phase)),</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span>phase,</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span><span class="st">'markers+lines'</span>,</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    name<span class="op">=</span><span class="st">'Phase Spectrum'</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>))</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>fig.update_layout(</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"FFT of PMF: Amplitude and Phase"</span>,</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    xaxis_title<span class="op">=</span><span class="st">"Frequency Index"</span>,</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    yaxis_title<span class="op">=</span><span class="st">"Value"</span>,</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    legend_title<span class="op">=</span><span class="st">"Spectrum"</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original PMF: [0.1  0.2  0.3  0.25 0.15]
FFT Result: [ 1.       +0.j         -0.2368034-0.07694209j -0.0131966+0.01816356j]
Amplitude: [1.         0.24898983 0.0224514 ]
Phase: [ 0.         -2.82743339  2.19911486]</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>                            <div id="480dbf70-31bd-439f-b13b-798a826434da" class="plotly-graph-div" style="height:525px; width:100%;"></div>            <script type="text/javascript">                require(["plotly"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById("480dbf70-31bd-439f-b13b-798a826434da")) {                    Plotly.newPlot(                        "480dbf70-31bd-439f-b13b-798a826434da",                        [{"mode":"markers+lines","name":"Amplitude Spectrum","x":[0,1,2],"y":[1.0,0.24898982848827805,0.022451398828979213],"type":"scatter"},{"mode":"markers+lines","name":"Phase Spectrum","x":[0,1,2],"y":[0.0,-2.827433388230814,2.1991148575128534],"type":"scatter"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmapgl":[{"type":"heatmapgl","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"},"margin":{"b":0,"l":0,"r":0,"t":30}}},"title":{"text":"FFT of PMF: Amplitude and Phase"},"xaxis":{"title":{"text":"Frequency Index"}},"yaxis":{"title":{"text":"Value"}},"legend":{"title":{"text":"Spectrum"}}},                        {"responsive": true}                    ).then(function(){
                            
var gd = document.getElementById('480dbf70-31bd-439f-b13b-798a826434da');
var x = new MutationObserver(function (mutations, observer) {{
        var display = window.getComputedStyle(gd).display;
        if (!display || display === 'none') {{
            console.log([gd, 'removed!']);
            Plotly.purge(gd);
            observer.disconnect();
        }}
}});

// Listen for the removal of the full notebook cells
var notebookContainer = gd.closest('#notebook-container');
if (notebookContainer) {{
    x.observe(notebookContainer, {childList: true});
}}

// Listen for the clearing of the current output cell
var outputEl = gd.closest('.output');
if (outputEl) {{
    x.observe(outputEl, {childList: true});
}}

                        })                };                });            </script>        </div>
</div>
</div>
<ol start="2" type="1">
<li><p><strong>Multiply them elementwise:</strong><br>
In the frequency domain, convolution becomes simple multiplication. That is, if you have two arrays representing the Fourier transforms of your PMFs, multiplying them elementwise (i.e., each frequency component multiplied by the corresponding component of the other array) yields the Fourier transform of the convolved PMF.</p></li>
<li><p><strong>Convert the product back to the time domain using the inverse FFT:</strong><br>
Once you have the product of the two Fourier-transformed arrays, you apply the inverse FFT (iFFT) to convert this product back to the time domain. The result is the convolution of the original PMFs—the distribution of the sum of the two independent random variables.</p></li>
</ol>
<p>This approach leverages the efficiency of the FFT, reducing computational complexity from (O(n^2)) to approximately (O(n n)).</p>
<hr>
</section>
<section id="code-example-fft-based-convolution-for-pmfs" class="level1">
<h1>3. Code Example: FFT-Based Convolution for PMFs</h1>
<p>Below is a Python example that: - Defines a PMF for a discrete random variable. - Uses an FFT-based function to compute the convolution. - Visualizes the original and convolved PMFs using Plotly.</p>
<p>Make sure to install the required packages if you haven’t already:</p>
<pre><code>pip install numpy plotly</code></pre>
<div id="45796e47" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Define a Sample Probability Mass Function (PMF) ---</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co"># For example, a custom PMF representing a discrete outcome (like a service time)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>pmf <span class="op">=</span> np.array([<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.25</span>, <span class="fl">0.15</span>])</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.isclose(np.<span class="bu">sum</span>(pmf), <span class="fl">1.0</span>), <span class="st">"PMF must sum to 1."</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Original PMF:"</span>, pmf)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># --- FFT-Based Convolution Function ---</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fft_convolve(a, b):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Convolve two 1-D arrays (PMFs) using FFT.</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">        a, b (np.array): Input probability distributions.</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co">        np.array: The convolution result, corresponding to the PMF of the sum.</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The full convolution length for sequences of lengths L and M is L + M - 1.</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(a) <span class="op">+</span> <span class="bu">len</span>(b) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Zero-pad to the next power of 2 for efficient FFT computation.</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    n_fft <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> <span class="bu">int</span>(np.ceil(np.log2(n)))</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.fft.rfft(a, n<span class="op">=</span>n_fft)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> np.fft.rfft(b, n<span class="op">=</span>n_fft)</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    conv_result <span class="op">=</span> np.fft.irfft(A <span class="op">*</span> B, n<span class="op">=</span>n_fft)[:n]</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> conv_result</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Compute Convolutions ---</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution of a single random variable (the original PMF)</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>pmf_single <span class="op">=</span> pmf</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution of the sum of 2 independent variables (e.g., total service time for 2 events)</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>pmf_two <span class="op">=</span> fft_convolve(pmf, pmf)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Distribution of the sum of 3 independent variables</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>pmf_three <span class="op">=</span> fft_convolve(pmf_two, pmf)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Prepare Data for Visualization ---</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a><span class="co"># Create x-axis values representing possible outcomes (e.g., sum of service times)</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>x_single <span class="op">=</span> np.arange(<span class="bu">len</span>(pmf_single))</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>x_two <span class="op">=</span> np.arange(<span class="bu">len</span>(pmf_two))</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>x_three <span class="op">=</span> np.arange(<span class="bu">len</span>(pmf_three))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original PMF: [0.1  0.2  0.3  0.25 0.15]</code></pre>
</div>
</div>
<div id="a45c240b" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Plot the Distributions using Plotly ---</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> go.Figure()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>fig.add_trace(go.Bar(x<span class="op">=</span>x_single, y<span class="op">=</span>pmf_single, name<span class="op">=</span><span class="st">"Single PMF"</span>))</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>fig.add_trace(go.Bar(x<span class="op">=</span>x_two, y<span class="op">=</span>pmf_two, name<span class="op">=</span><span class="st">"Sum of 2 Variables"</span>))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>fig.add_trace(go.Bar(x<span class="op">=</span>x_three, y<span class="op">=</span>pmf_three, name<span class="op">=</span><span class="st">"Sum of 3 Variables"</span>))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>fig.update_layout(</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    title<span class="op">=</span><span class="st">"Probability Distributions via Convolution (Using FFT)"</span>,</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    xaxis_title<span class="op">=</span><span class="st">"Outcome (Sum)"</span>,</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    yaxis_title<span class="op">=</span><span class="st">"Probability"</span>,</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    barmode<span class="op">=</span><span class="st">"group"</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>fig.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>                            <div id="6b38fe9a-007a-4b60-84b5-719e40f1eb82" class="plotly-graph-div" style="height:525px; width:100%;"></div>            <script type="text/javascript">                require(["plotly"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById("6b38fe9a-007a-4b60-84b5-719e40f1eb82")) {                    Plotly.newPlot(                        "6b38fe9a-007a-4b60-84b5-719e40f1eb82",                        [{"name":"Single PMF","x":[0,1,2,3,4],"y":[0.1,0.2,0.3,0.25,0.15],"type":"bar"},{"name":"Sum of 2 Variables","x":[0,1,2,3,4,5,6,7,8],"y":[0.00999999999999999,0.039999999999999994,0.1,0.17,0.22,0.21000000000000002,0.1525,0.07499999999999998,0.022499999999999985],"type":"bar"},{"name":"Sum of 3 Variables","x":[0,1,2,3,4,5,6,7,8,9,10,11,12],"y":[0.0010000000000000009,0.0059999999999999915,0.020999999999999998,0.05149999999999999,0.0975,0.14700000000000002,0.18075000000000002,0.1815,0.1485,0.09662499999999997,0.04837499999999997,0.016874999999999973,0.003374999999999982],"type":"bar"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmapgl":[{"type":"heatmapgl","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"},"margin":{"b":0,"l":0,"r":0,"t":30}}},"title":{"text":"Probability Distributions via Convolution (Using FFT)"},"xaxis":{"title":{"text":"Outcome (Sum)"}},"yaxis":{"title":{"text":"Probability"}},"barmode":"group"},                        {"responsive": true}                    ).then(function(){
                            
var gd = document.getElementById('6b38fe9a-007a-4b60-84b5-719e40f1eb82');
var x = new MutationObserver(function (mutations, observer) {{
        var display = window.getComputedStyle(gd).display;
        if (!display || display === 'none') {{
            console.log([gd, 'removed!']);
            Plotly.purge(gd);
            observer.disconnect();
        }}
}});

// Listen for the removal of the full notebook cells
var notebookContainer = gd.closest('#notebook-container');
if (notebookContainer) {{
    x.observe(notebookContainer, {childList: true});
}}

// Listen for the clearing of the current output cell
var outputEl = gd.closest('.output');
if (outputEl) {{
    x.observe(outputEl, {childList: true});
}}

                        })                };                });            </script>        </div>
</div>
</div>
<hr>
</section>
<section id="explanation-of-the-code" class="level1">
<h1>4. Explanation of the Code</h1>
<section id="defining-a-pmf" class="level3">
<h3 class="anchored" data-anchor-id="defining-a-pmf">Defining a PMF</h3>
<p>In this example, we define a simple PMF: - <strong><code>pmf</code></strong>: A NumPy array representing a discrete probability distribution (for example, service times or waiting times).<br>
- We use an assertion to ensure that the PMF sums to 1.</p>
</section>
<section id="fft-based-convolution-function" class="level3">
<h3 class="anchored" data-anchor-id="fft-based-convolution-function">FFT-Based Convolution Function</h3>
<ul>
<li><strong><code>fft_convolve(a, b)</code></strong>:
<ul>
<li><strong>Length Calculation:</strong><br>
Computes the expected length ( n = (a) + (b) - 1 ) of the convolution.</li>
<li><strong>Zero-Padding:</strong><br>
Pads the arrays to the next power of 2 (stored in <code>n_fft</code>) to maximize FFT efficiency.</li>
<li><strong>FFT Computation:</strong><br>
Uses <code>np.fft.rfft</code> to compute the FFTs of the padded PMFs.</li>
<li><strong>Elementwise Multiplication:</strong><br>
Multiplies the FFTs elementwise. This step corresponds to the convolution operation in the time (or probability) domain.</li>
<li><strong>Inverse FFT and Trimming:</strong><br>
Applies the inverse FFT with <code>np.fft.irfft</code> and slices the result to return only the first ( n ) elements—the actual convolution result.</li>
</ul></li>
</ul>
</section>
<section id="detailed-explanation-of-the-fft-steps" class="level3">
<h3 class="anchored" data-anchor-id="detailed-explanation-of-the-fft-steps">Detailed Explanation of the FFT Steps</h3>
<ol type="1">
<li><p><strong>Transform Both PMFs into the Frequency Domain Using FFT:</strong><br>
Applying the FFT to each PMF converts it from the time (or probability) domain into the frequency domain. In this new domain, the data is represented as a series of complex numbers, each corresponding to a specific frequency component. The magnitude and phase of these complex numbers capture the contribution of each frequency to the overall shape of the PMF.</p></li>
<li><p><strong>Multiply Them Elementwise:</strong><br>
In the frequency domain, convolution becomes a simple multiplication of corresponding frequency components. By multiplying the two Fourier-transformed arrays elementwise, you effectively compute the Fourier transform of the convolution of the original PMFs. This step leverages the Convolution Theorem, which states that the Fourier transform of a convolution is equal to the product of the Fourier transforms.</p></li>
<li><p><strong>Convert the Product Back to the Time Domain Using the Inverse FFT:</strong><br>
Finally, applying the inverse FFT (iFFT) to the product converts the data back to the time domain. The resulting array represents the convolution of the original PMFs—the distribution of the sum of the independent random variables. Only the first ( n ) elements (where ( n = (a) + (b) - 1 )) are kept since that corresponds to the valid convolution result.</p></li>
</ol>
</section>
<section id="computing-convolutions" class="level3">
<h3 class="anchored" data-anchor-id="computing-convolutions">Computing Convolutions</h3>
<ul>
<li><strong><code>pmf_two</code></strong>: Represents the probability distribution for the sum of two independent random variables (each with PMF <code>pmf</code>).</li>
<li><strong><code>pmf_three</code></strong>: Represents the distribution for the sum of three independent random variables, computed by convolving the two-variable PMF with the original PMF.</li>
</ul>
</section>
<section id="visualization-with-plotly" class="level3">
<h3 class="anchored" data-anchor-id="visualization-with-plotly">Visualization with Plotly</h3>
<ul>
<li><strong>Bar Charts:</strong><br>
We use Plotly’s bar chart functionality to visualize the PMFs:
<ul>
<li>The x-axis represents the possible outcomes (e.g., the total sum).</li>
<li>The y-axis shows the probability for each outcome.</li>
</ul></li>
<li><strong>Grouped Layout:</strong><br>
The distributions for one, two, and three summed variables are plotted together for easy comparison.</li>
</ul>
<hr>
</section>
</section>
<section id="conclusion" class="level1">
<h1>5. Conclusion</h1>
<p>This tutorial has shown how FFT can be leveraged to efficiently compute the convolution of probability distributions. This is particularly useful in probability and statistics when you need to find the distribution of a sum of independent random variables.</p>
<p>Key takeaways: - <strong>FFT for Convolution:</strong><br>
The FFT reduces the computational cost of convolving long PMFs, enabling efficient analysis. - <strong>Application to PMFs:</strong><br>
Convolving a PMF with itself gives you the distribution of the sum of independent events—a common problem in probability (e.g., total service time, sum of dice rolls). - <strong>Visualization:</strong><br>
Plotly provides interactive plots that help you visualize and compare the original and convolved distributions.</p>
<p>Feel free to experiment with different PMFs and convolution depths to see how the distribution evolves when summing independent random variables!</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/nl9TZanwbBk?si=fZpagWLce90Yb2x6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>
<iframe width="560" height="315" src="https://www.youtube.com/embed/E8HeD-MUrjY?si=Wl4j47AR_7N02EAA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen="">
</iframe>
<section id="theoretical-background-dft-on-a-constrained-dataset" class="level2">
<h2 class="anchored" data-anchor-id="theoretical-background-dft-on-a-constrained-dataset">Theoretical Background: DFT on a Constrained Dataset</h2>
<p>A multi-dimensional DFT can be applied even if the data points lie on a constrained subset of the full grid. In this case, each vector <strong>X</strong> has components summing to a constant N, meaning the data lives on an <span class="math inline">\(n\)</span>-dimensional hyperplane within an <span class="math inline">\((n+1)\)</span>-dimensional space. Essentially, one degree of freedom is lost due to the linear constraint (the dataset is “degenerate” in one dimension, effectively <span class="math inline">\((n+1)-1 = n\)</span> dimensional) (<a href="https://encyclopediaofmath.org/wiki/Multinomial_distribution#:~:text=are%20the%20parameters%20of%20the,A%20multinomial%20distribution%20is%20a">Multinomial distribution - Encyclopedia of Mathematics</a>). The multi-D DFT still represents <span class="math inline">\(f(X)\)</span> as a superposition of multidimensional sinusoidal patterns (plane waves) across the domain (<a href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform#:~:text=As%20the%20one,broken%20up%20into%20plane%20waves">Discrete Fourier transform - Wikipedia</a>), but those patterns must respect the sum constraint. In practice, there are two conceptual ways to handle the transform: either <em>embed</em> the data in a full <span class="math inline">\((n+1)\)</span>-D array or define the transform intrinsically on the <span class="math inline">\(n\)</span>-D constrained surface. In the embedding approach, we place <span class="math inline">\(f(X)\)</span> in an <span class="math inline">\((N+1)^{(n+1)}\)</span> grid (since each <span class="math inline">\(x_i\)</span> ranges from 0 to N) and set <span class="math inline">\(f=0\)</span> for points that violate <span class="math inline">\(x_0+\cdots+x_n=N\)</span>. A standard <span class="math inline">\((n+1)\)</span>-D DFT can then be computed over this extended array. Because <span class="math inline">\(f\)</span> is zero outside the valid hyperplane, the Fourier transform naturally focuses on variations along the allowed subspace. An alternative view is to eliminate one coordinate using <span class="math inline">\(x_n = N - (x_0+\cdots+x_{n-1})\)</span>, reducing the problem to <span class="math inline">\(n\)</span> independent coordinates. The DFT can then be formulated on this <span class="math inline">\(n\)</span>-dimensional domain, using basis functions that account for the relationship among components. For instance, one can restrict the Fourier basis to those frequency vectors that sum to zero, which are orthogonal to the vector <span class="math inline">\((1,1,\dots,1)\)</span> that defines the constraint. This effectively embeds the constraint into the basis functions themselves. Notably, research in numerical analysis has developed Fourier methods on simplex domains (the domain of vectors with a fixed sum) – including definitions of Fourier series, DFT and even FFT algorithms on these non-tensor-product domains (<a href="https://journal.global-sci.org/intro/article_detail.html?journal=undefined&amp;article_id=8754#:~:text=In%20this%20paper%20we%20propose,The%20relationship%20between">Multivariate Fourier Transform Methods over Simplex and Super-Simplex Domains</a>). This theoretical foundation confirms that it’s valid to perform harmonic analysis on a constrained dataset by working in the reduced-dimensional subspace or appropriately accounting for the constraint in the transform. In summary, a multi-D DFT can be applied to <span class="math inline">\(\{X: \sum_i x_i=N\}\)</span> by either zero-padding the data in a full grid or by using a specialized transform basis on the hyperplane, with the understanding that the data effectively resides in a lower-dimensional space.</p>
</section>
<section id="techniques-to-handle-the-sum-constraint-in-the-fourier-framework" class="level2">
<h2 class="anchored" data-anchor-id="techniques-to-handle-the-sum-constraint-in-the-fourier-framework">Techniques to Handle the Sum Constraint in the Fourier Framework</h2>
<p>To incorporate the constraint <span class="math inline">\(x_0+\cdots+x_n=N\)</span> directly into Fourier analysis, several techniques can be used:</p>
<ul>
<li><p><strong>Dimension Reduction (Eliminate a Variable):</strong> One straightforward approach is to use the constraint to remove one variable from the analysis. For example, set <span class="math inline">\(x_n = N - (x_0+\cdots+x_{n-1})\)</span> and substitute this into the transform. The Fourier basis functions can be written in terms of the first <span class="math inline">\(n\)</span> components, with <span class="math inline">\(x_n\)</span> no longer independent. In the exponent of the DFT’s kernel <span class="math inline">\(e^{-i(k_0x_0+\cdots+k_n x_n)}\)</span>, substitute <span class="math inline">\(x_n = N-\sum_{j=0}^{n-1}x_j\)</span>. This yields an exponent <span class="math inline">\(e^{-i[(k_0-k_n)x_0 + \cdots + (k_{n-1}-k_n)x_{n-1} + k_n N]}\)</span>. The term <span class="math inline">\(e^{-ik_n N}\)</span> is a constant phase factor (since N is fixed), and the important dependence is on the <em>differences</em> <span class="math inline">\(h_j = k_j - k_n\)</span> for <span class="math inline">\(j=0,\dots,n-1\)</span>. In effect, only <span class="math inline">\(n\)</span> independent frequency parameters (the <span class="math inline">\(h_j\)</span>) matter for the variation of <span class="math inline">\(f\)</span> on the constrained domain. One can thus restrict to frequency vectors that satisfy a relation (like <span class="math inline">\(\sum k_i = 0\)</span> or treat one component as reference) so that the basis functions inherently respect the sum constraint. This technique builds the constraint into the Fourier basis: the resulting sinusoids vary only along directions within the hyperplane.</p></li>
<li><p><strong>Lagrange Multiplier or Delta Function Enforcement:</strong> Another technique is to enforce the sum constraint via a delta function in the transform integral/sum. In discrete form, one can insert a Kronecker delta <span class="math inline">\(\delta(x_0+\cdots+x_n - N)\)</span> into the DFT formula to ensure only valid <span class="math inline">\(X\)</span> contribute. Equivalently, one may use an integral representation of the delta:<br>
<span class="math display">\[\delta\Big(\sum_{i=0}^n x_i - N\Big) = \frac{1}{2\pi}\int_{-\pi}^{\pi} e^{i\omega(\sum_i x_i - N)}\,d\omega.\]</span><br>
Including this in the sum for the Fourier transform yields:<br>
<span class="math display">\[F(k_0,\dots,k_n) = \sum_{X} f(X)\,\delta(\textstyle\sum_i x_i - N)\,e^{-i(k_0x_0+\cdots+k_nx_n)}.\]</span><br>
Using the identity above, the <span class="math inline">\(\omega\)</span>-integral can be exchanged with the sum, which effectively links the frequencies <span class="math inline">\(k_i\)</span> through the factor <span class="math inline">\(e^{i\omega \sum_i x_i} = e^{i\omega N}\)</span> times <span class="math inline">\(e^{-i\sum_i k_i x_i}\)</span>. Stationary phase in <span class="math inline">\(\omega\)</span> (or simply evaluating the integral) will impose a condition on <span class="math inline">\(k\)</span> (such as <span class="math inline">\(\sum k_i = \omega\)</span>) that mirrors the real-space constraint. In simpler terms, this approach introduces an auxiliary frequency (Fourier dual to the sum constraint) to enforce <span class="math inline">\(x_0+\cdots+x_n=N\)</span>, coupling the frequency components. While more abstract, this embeds the constraint in the transform mathematically and can lead to analytical simplifications in some cases (e.g.&nbsp;deriving closed-form transforms). A concrete example of this idea appears in probability theory: the <strong>characteristic function</strong> (Fourier transform of the probability mass function) of a multinomial distribution (which lives on <span class="math inline">\(\{x_i\}\)</span> summing to N) factorizes neatly. It is given by <span class="math inline">\(M(t_1,\dots,t_k)= (p_1 e^{it_1} + \cdots + p_k e^{it_k})^N\)</span> (<a href="https://encyclopediaofmath.org/wiki/Multinomial_distribution#:~:text=%24%29,a%20multinomial%20distribution%20is">Multinomial distribution - Encyclopedia of Mathematics</a>), which inherently uses the sum <span class="math inline">\(N\)</span> in the exponent. This formula comes from treating each trial’s contribution independently and then enforcing that exactly <span class="math inline">\(N\)</span> trials occur – effectively an application of the exponential trick to embed the sum constraint. Such factorized expressions illustrate how a sum constraint can be handled by introducing a conjugate variable (here the inside of the power) that “collects” the contributions of each part while fixing the total.</p></li>
<li><p><strong>Specialized Basis on the Simplex:</strong> Instead of using the standard Fourier basis on a cube and then constraining it, one can construct an orthogonal basis of functions defined <em>on the simplex</em> (the set of vectors summing to <span class="math inline">\(N\)</span>). Researchers have extended Fourier analysis to simplex domains by finding appropriate eigenfunctions or sinusoidal bases that satisfy the boundary conditions of the simplex (<a href="https://journal.global-sci.org/intro/article_detail.html?journal=undefined&amp;article_id=8754#:~:text=In%20this%20paper%20we%20propose,The%20relationship%20between">Multivariate Fourier Transform Methods over Simplex and Super-Simplex Domains</a>). For instance, there are generalized sine and cosine transforms defined on a simplex (with certain orthogonality properties) that inherently respect the condition <span class="math inline">\(\sum x_i = N\)</span>. Using such a basis means the constraint is built in by design – any function expanded in this basis will automatically satisfy the sum constraint (or be zero off the domain). While this approach is more complex, it ensures <em>validity</em> in that we never leave the feasible domain during analysis. It connects to the idea of Fourier transform on a finite group or coset: the set <span class="math inline">\(\{X: \sum x_i=N\}\)</span> can be seen as a slice through <span class="math inline">\(\mathbb{Z}^{n+1}\)</span>, and one can perform a transform on this slice by considering characters (complex exponentials) that are constant along directions normal to the slice. In practical terms, using a simplex-based Fourier basis might involve precomputing those basis functions (which could be related to e.g.&nbsp;multivariate Jacobi polynomials or other orthogonal polynomials on a simplex) and then projecting <span class="math inline">\(f(X)\)</span> onto them. This is less common than standard FFT approaches, but it directly embeds the constraint into the analysis.</p></li>
<li><p><strong>Zero-Padding and Symmetry:</strong> A simpler (if brute-force) method is to include the constraint by symmetry and padding: as mentioned, fill an <span class="math inline">\((N+1)\times\cdots\times(N+1)\)</span> grid with the known values of <span class="math inline">\(f\)</span> on valid points and zeros elsewhere. The constraint’s effect is then captured by the pattern of zeros. When taking the DFT of this padded array, the fact that <span class="math inline">\(f\)</span> is zero except on the hyperplane means the frequency-domain representation will have certain symmetries. In particular, shifting the input <span class="math inline">\(X\)</span> by a vector that moves along the constraint surface versus off it will produce different contributions. One notable result is that adding a constant to all components <span class="math inline">\(x_i\)</span> (which moves off the hyperplane) has no effect on <span class="math inline">\(f\)</span>, so in frequency space this corresponds to certain frequency combinations yielding identical or related spectral coefficients (specifically, a mode where all <span class="math inline">\(k_i\)</span> are equal cannot influence the function’s variation on the hyperplane except as an overall phase). In effect, the Fourier transform will show that only combinations of frequencies that <em>differ</em> among components drive variation in <span class="math inline">\(f(X)\)</span>. By analyzing those, one inherently is looking at patterns that respect the zero-sum of index shifts. This zero-padding technique is straightforward, though not the most efficient, and it ensures that when you invert the transform, the result will automatically satisfy the constraint (since the inverse FFT will reproduce the same zeros outside the domain).</p></li>
</ul>
<p>Each of these techniques enforces the <span class="math inline">\(x_0+\cdots+x_n=N\)</span> condition in a different way – either by reducing the problem’s dimensionality, adding analytical constraints into the transform, or choosing a basis aligned with the constraint. The goal is to avoid “mixing” valid and invalid states during the Fourier analysis, thereby ensuring that any patterns or reconstructed signals remain within the physically or combinatorially valid domain.</p>
</section>
<section id="practical-implementation-strategies-python-and-numerical-tools" class="level2">
<h2 class="anchored" data-anchor-id="practical-implementation-strategies-python-and-numerical-tools">Practical Implementation Strategies (Python and Numerical Tools)</h2>
<p>Implementing a multi-dimensional DFT for constrained data can be approached with standard FFT libraries or more specialized tools, depending on the data structure:</p>
<ul>
<li><p><strong>Embedding in a Full Grid and Using FFT:</strong> If the dataset of <span class="math inline">\(f(X)\)</span> values is available (or can be computed) for <em>all</em> combinations satisfying the sum constraint, one practical approach is to embed this data into a full <span class="math inline">\((n+1)\)</span>-dimensional array of size <span class="math inline">\((N+1)\)</span> in each dimension. Positions corresponding to invalid vectors (where the sum is not <span class="math inline">\(N\)</span>) are set to zero. Then, one can apply a regular FFT on this multi-dimensional array. For example, using NumPy in Python:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">5</span>   <span class="co"># total sum</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">2</span>   <span class="co"># so X has length 3 (n+1=3 dimensions)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize full grid array (dimensions N+1 by N+1 by ... (n+1 times))</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>shape <span class="op">=</span> (N<span class="op">+</span><span class="dv">1</span>,)<span class="op">*</span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>f_full <span class="op">=</span> np.zeros(shape, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Populate f_full for valid combinations x0+x1+...+x_n = N</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x0 <span class="kw">in</span> <span class="bu">range</span>(N<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x1 <span class="kw">in</span> <span class="bu">range</span>(N<span class="op">+</span><span class="dv">1</span> <span class="op">-</span> x0):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        x2 <span class="op">=</span> N <span class="op">-</span> x0 <span class="op">-</span> x1</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        f_full[x0, x1, x2] <span class="op">=</span> compute_f(x0, x1, x2)  <span class="co"># placeholder for actual f</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Now perform multi-dimensional FFT on the full array</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> np.fft.fftn(f_full)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here <code>F</code> will contain the DFT coefficients (complex amplitudes) for each frequency index <span class="math inline">\((k_0,k_1,k_2)\)</span>. One could then analyze <code>F</code> to find dominant frequency components, or perform an inverse FFT (<code>np.fft.ifftn</code>) on a modified <code>F</code> to reconstruct or filter the function. This method leverages highly-optimized FFT algorithms. Its downside is memory and compute cost: the array size is <span class="math inline">\((N+1)^{(n+1)}\)</span>, which can be much larger than the number of valid points. Nonetheless, for moderate <span class="math inline">\(N\)</span> and <span class="math inline">\(n\)</span>, this brute-force approach is straightforward and guarantees that the reconstruction will honor the constraint (since we never provided any data outside it, those regions remain zero after inverse transform). It effectively converts the non-uniform problem into a uniform one that FFT can handle (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=NUFFTs%20or%20NFFTs%20and%20have,17">Non-uniform discrete Fourier transform - Wikipedia</a>) (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=approximation.,17">Non-uniform discrete Fourier transform - Wikipedia</a>). Note that the FFT assumes the data is periodic at the array boundaries; if the function <span class="math inline">\(f(X)\)</span> does not naturally tile periodically, this embedding implies a periodic extension where <span class="math inline">\(f\)</span> is zero outside the simplex. This could introduce edge effects in frequency space if <span class="math inline">\(f\)</span> has discontinuities at the domain boundary. In practice, if <span class="math inline">\(f\)</span> is smoothly defined only on the simplex, one might mitigate artifacts by windowing or padding beyond N slightly, but that goes deeper into signal processing heuristics.</p></li>
<li><p><strong>Non-Uniform Fourier Transform (NUFFT):</strong> If the dataset consists of randomly sampled points (not filling out the entire set of combinations) or if we want to avoid allocating a mostly-zero grid, we can use non-uniform FFT techniques. The <em>non-uniform discrete Fourier transform</em> is a generalization of the DFT that handles data on arbitrary sample positions (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=In%20applied%20mathematics%2C%20the%20non,3">Non-uniform discrete Fourier transform - Wikipedia</a>). In our scenario, the sample positions are the integer vectors <span class="math inline">\(X\)</span> on the hyperplane. Libraries like <strong>FINUFFT</strong> or <strong>PyNUFFT</strong> allow you to input an arbitrary list of sample coordinates and values, and compute the frequency spectrum efficiently (often in <span class="math inline">\(O(M \log M)\)</span> time instead of <span class="math inline">\(O(M^2)\)</span>, where <span class="math inline">\(M\)</span> is the number of sample points) (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=While%20a%20naive%20application%20of,17">Non-uniform discrete Fourier transform - Wikipedia</a>). These algorithms work by clever interpolation and oversampling schemes that map non-grid points to a uniform grid FFT internally (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=NUFFTs%20or%20NFFTs%20and%20have,17">Non-uniform discrete Fourier transform - Wikipedia</a>). For example, using a NUFFT library, you could provide the list of coordinates <span class="math inline">\([(x_0,\dots,x_n)]\)</span> (with <span class="math inline">\(\sum x_i=N\)</span> for each) and the corresponding <span class="math inline">\(f(X)\)</span> values, and request the transform at a set of frequency points. This is especially useful if your data is <em>sparse</em> (perhaps you only have values at some random sample vectors, not all possible ones) or if <span class="math inline">\(N\)</span> is large so that a full grid is infeasible. Do note that to reconstruct the entire function via inverse NUFFT, you would typically need as many frequency samples as data points (or some interpolation scheme). If you have fewer samples than the full domain, you might treat reconstruction as a regression or interpolation problem: for instance, fit a truncated Fourier series to the known data and then evaluate it. Python’s scientific stack may not have NUFFT in <code>numpy</code> directly, but libraries like <strong>SciPy</strong> (with <code>scipy.fftpack</code> or <code>scipy.fft</code>) assume uniform grids, so one would turn to external packages (FINUFFT, pynfft, or even implement a custom least-squares using <code>np.fft</code> on an oversampled grid).</p></li>
<li><p><strong>Iterative or Convolution Approaches:</strong> In some cases, the constrained nature of the domain can be exploited algorithmically. For example, if <span class="math inline">\(n+1\)</span> is the number of components, one can construct <span class="math inline">\(f(X)\)</span> by iterative convolution of contributions from each component. This is essentially how one would compute the distribution of a sum of random variables: start with the distribution for <span class="math inline">\(x_0\)</span>, then convolve with the distribution of <span class="math inline">\(x_1\)</span>, etc., <span class="math inline">\(n+1\)</span> times. If <span class="math inline">\(f(X)\)</span> has a structure that makes it decomposable (say <span class="math inline">\(f(X)\)</span> is some product or convolution of functions of individual <span class="math inline">\(x_i\)</span>), then multi-dimensional FFT can be done by repeated 1D FFTs using convolution theorems. However, for a general arbitrary <span class="math inline">\(f\)</span> given as a table, this may not apply. Still, understanding <span class="math inline">\(f\)</span> as, for example, a result of adding <span class="math inline">\(n+1\)</span> independent contributions could hint at using 1D FFT cyclically. A simple practical strategy along these lines: treat one index (say <span class="math inline">\(x_0\)</span>) as a “slow” dimension and the sum of the rest as a “fast” dimension. You can loop over <span class="math inline">\(x_0\)</span>, take a 1D FFT in the combined <span class="math inline">\(x_1,\dots,x_n\)</span> direction (which actually corresponds to different remaining sums), and then combine results – but this becomes complex and is essentially re-deriving an <span class="math inline">\(n\)</span>-D FFT. In most cases, leveraging existing <span class="math inline">\(n\)</span>-D FFT implementations via embedding or using a specialized NUFFT is the preferable route.</p></li>
<li><p><strong>Reconstruction and Inverse Transform:</strong> Once a forward DFT is obtained (by any method above), reconstructing <span class="math inline">\(f(X)\)</span> means performing an inverse DFT and then extracting the values on the constrained domain. If a full-grid FFT approach was used, this is as simple as calling <code>ifftn</code> and reading off the real parts at the integer coordinates (floating-point error aside, they should match the original <span class="math inline">\(f(X)\)</span>). If a NUFFT was used, many libraries support an inverse operation as well – or one can set up a system of equations to solve for the inverse. It’s important to emphasize that if <span class="math inline">\(f(X)\)</span> is only known on the hyperplane, any Fourier-based interpolation outside that hyperplane is an extrapolation. Thus, we ensure to evaluate the inverse transform only at points satisfying the constraint (or we enforce through basis selection that the function is zero elsewhere). In Python, after doing the <code>fftn</code> as above, one could modify certain frequency components (for example, to filter noise or emphasize certain patterns) and then do <code>f_back = np.fft.ifftn(F_modified).real</code>. The array <code>f_back</code> will again have zeros (or negligible values) off the hyperplane and the reconstructed <span class="math inline">\(f\)</span> on the hyperplane. If we wanted just the list of reconstructed values, we could then iterate over valid indices (or use a mask) to collect them. In summary, the practical implementation can range from a straightforward NumPy FFT on a padded array to more advanced non-uniform Fourier transforms. Which is appropriate depends on data availability (complete grid vs random samples) and size (small enough for brute-force vs needing an optimized NUFFT).</p></li>
</ul>
</section>
<section id="example-applications-and-use-cases" class="level2">
<h2 class="anchored" data-anchor-id="example-applications-and-use-cases">Example Applications and Use Cases</h2>
<p>Applying multi-dimensional Fourier analysis to data with a fixed-sum constraint can be valuable in various contexts:</p>
<ul>
<li><p><strong>Compositional Data Analysis:</strong> In fields like geology, chemistry, or economics, one often deals with <em>compositional data</em> – vectors of components that sum to a constant total (e.g.&nbsp;proportions summing to 1, or percentages summing to 100%). For instance, a soil sample might be described by percentages of different minerals that always sum to 100%. If we have a function <span class="math inline">\(f(X)\)</span> defined on these compositions (perhaps an index of material strength, or a cost function depending on resource allocation), applying a multi-D DFT can reveal underlying patterns. For example, there might be a periodic oscillation in <span class="math inline">\(f\)</span> whenever one component fraction goes up and another goes down (indicating a trade-off effect). Fourier analysis would capture this as a frequency spike corresponding to that pairwise substitution. By embedding the compositional constraint in the analysis, we ensure that any identified frequency patterns correspond to actual variations in feasible compositions (and not artifacts of moving outside the valid range). This approach could help, say, in finding cyclical patterns in how output quality changes as you vary a recipe of ingredients that must sum to a fixed amount.</p></li>
<li><p><strong>Multinomial and Categorical Data Patterns:</strong> Consider an experiment with <span class="math inline">\(n+1\)</span> possible outcomes (categories) that occur <span class="math inline">\(x_0,\dots,x_n\)</span> times, with a fixed total <span class="math inline">\(N\)</span> trials. The space of possible outcome counts is constrained by <span class="math inline">\(\sum x_i = N\)</span>. If <span class="math inline">\(f(X)\)</span> represents something like the log-likelihood of observing a particular count vector <span class="math inline">\(X\)</span>, or some goodness-of-fit measure, Fourier analysis can be used to study its structure. In fact, as noted earlier, the characteristic function of the multinomial distribution is one such Fourier transform, and it has a simple form <span class="math inline">\((p_1 e^{it_1}+\cdots+p_{n+1} e^{it_{n+1}})^N\)</span> (<a href="https://encyclopediaofmath.org/wiki/Multinomial_distribution#:~:text=%24%29,a%20multinomial%20distribution%20is">Multinomial distribution - Encyclopedia of Mathematics</a>). That formula is not just useful for probability theory (deriving moments, correlations, etc.), but it also exemplifies how a constrained sum leads to a <strong>convolutional structure</strong> in the frequency domain: the product of <span class="math inline">\((p_1 e^{it_1}+\cdots)\)</span> terms <span class="math inline">\(N\)</span> times indicates that each trial contributes independently to frequencies and the total effect is the <span class="math inline">\(N\)</span>-fold convolution. In a more general sense, if <span class="math inline">\(f(X)\)</span> is some measured response on outcome count vectors, taking a DFT might highlight if <span class="math inline">\(f\)</span> is largely driven by certain linear combinations of counts. For example, if <span class="math inline">\(f\)</span> mainly varies with the difference <span class="math inline">\(x_0 - x_1\)</span> (holding others fixed), then the Fourier mode corresponding to <span class="math inline">\((1,-1,0,\dots,0)\)</span> (in the frequency basis of the hyperplane) will show a strong amplitude. Use cases here include analysis of voting data (where votes for candidates must sum to N) to find patterns like swing behavior between two specific parties, or analyzing contingency tables in statistics where one dimension is constrained. Fourier methods can detect interaction patterns in such tables analogous to how spectral analysis finds frequency content in time series.</p></li>
<li><p><strong>Reconstructing Expensive Objective Functions:</strong> In optimization or simulation, one might have an objective function <span class="math inline">\(f(x_0,\dots,x_n)\)</span> that is expensive to evaluate, but known to obey a conservation law <span class="math inline">\(x_0+\cdots+x_n=N\)</span> (for instance, distributing a fixed budget across <span class="math inline">\(n+1\)</span> projects and measuring performance). By sampling <span class="math inline">\(f\)</span> at various allocation vectors <span class="math inline">\(X\)</span> (perhaps randomly), one can attempt to reconstruct or approximate <span class="math inline">\(f\)</span> using Fourier techniques. If <span class="math inline">\(f\)</span> is reasonably smooth over the simplex of allocations, it may be approximated by a truncated Fourier series (just as a smooth periodic function can be approximated by a few low-frequency Fourier components). Practically, one could use the sample points and values to fit a model <span class="math inline">\(f(X) \approx \sum_{k} c_k e^{i(k\cdot X)}\)</span> with appropriate constraint on <span class="math inline">\(k\)</span> (such as <span class="math inline">\(\sum k_i=0\)</span> so that <span class="math inline">\(k\cdot X\)</span> really only depends on the internal degrees of freedom). This is essentially a form of response surface modeling. The benefit is that once <span class="math inline">\(f\)</span> is reconstructed (even approximately), one can evaluate it cheaply anywhere on the domain or analyze its behavior by examining the Fourier coefficients <span class="math inline">\(c_k\)</span>. The fixed-sum constraint reduces the dimensionality of the problem and can be leveraged to cut down the number of terms needed or to simplify the fitting (since one coordinate is dependent). A use case might be in <strong>project portfolio optimization</strong>: say <span class="math inline">\(x_i\)</span> is investment in project <span class="math inline">\(i\)</span> with total budget <span class="math inline">\(N\)</span> fixed. If <span class="math inline">\(f(X)\)</span> is some return or risk measure, a Fourier analysis could identify, for example, that <span class="math inline">\(f\)</span> has an interaction term between projects 1 and 2 (seen as a high-frequency component along the direction where <span class="math inline">\(x_1\)</span> increases while <span class="math inline">\(x_2\)</span> decreases). This insight could guide the decision maker about trade-offs. Similarly, in engineering, if <span class="math inline">\(X\)</span> represents how one distributes material in different components of a system (with fixed total mass), and <span class="math inline">\(f\)</span> is system reliability, Fourier analysis might expose which redistribution of material causes oscillatory changes in reliability.</p></li>
<li><p><strong>Signal or Image Processing with Sum Constraints:</strong> Although less common, there are scenarios in image processing or signal processing where a constraint similar to a fixed sum appears. One example is analyzing patterns in <em>balanced sequences</em>. Suppose you have a binary sequence of length N with equal numbers of 0s and 1s (so sum is N/2). This is a 1D sequence version of a sum-constrained set. If we assign <span class="math inline">\(x_0\)</span> = number of 1s and <span class="math inline">\(x_1\)</span> = number of 0s (so <span class="math inline">\(x_0+x_1=N\)</span>), <span class="math inline">\(f(x_0,x_1)\)</span> could be some complexity or energy measure of sequences with those counts. A 2D DFT on such data could help identify if there’s a periodic preference in how the 1s and 0s are arranged. More directly, one could look at 2D images where each pixel’s R, G, B values sum to a constant (rare in practice unless a normalization is applied). In any case, whenever the data fundamentally lies on a hyperplane due to a conservation law or normalization, embedding that fact into Fourier analysis ensures that discovered frequency components correspond to actual variations rather than moving outside the feasible set.</p></li>
</ul>
<p>Overall, the approach is beneficial when you suspect that the objective function or data has <em>structure</em> that can be exploited. Periodic or oscillatory behavior with respect to changes in one part of the vector balanced by opposite changes in another part will manifest in the Fourier spectrum. By using the multi-dimensional DFT, one can identify such patterns (for example, a strong frequency component might indicate a repeating pattern or symmetry in <span class="math inline">\(f\)</span> along the constraint surface). This can be used for feature extraction, data compression (approximating <span class="math inline">\(f\)</span> with a few Fourier modes), or simply gaining insight into how the function behaves. For probabilistic data (multinomial distributions, contingency tables), Fourier methods connect to characteristic functions and moment-generating functions, providing another analytical tool. For deterministic simulations or measurements, it offers a way to interpolate and detect interactions. In summary, any scenario with a fixed-sum vector (from physics – e.g.&nbsp;momentum or mass conservation – to economics – budget allocation – to computer science – fixed-length codes or schedules) could potentially leverage this Fourier approach to analyze or reconstruct the underlying function more efficiently than naive grid evaluations.</p>
</section>
<section id="computational-efficiency-and-limitations" class="level2">
<h2 class="anchored" data-anchor-id="computational-efficiency-and-limitations">Computational Efficiency and Limitations</h2>
<p>While Fourier techniques are powerful, applying them to high-dimensional constrained data comes with computational considerations:</p>
<ul>
<li><p><strong>Dimensionality and Data Size:</strong> The number of points on the hyperplane grows combinatorially with <span class="math inline">\(N\)</span> and <span class="math inline">\(n\)</span>. Specifically, the count of integer solutions to <span class="math inline">\(x_0+\cdots+x_n=N\)</span> (with <span class="math inline">\(x_i\ge0\)</span>) is <span class="math inline">\(\binom{N+n}{n}\)</span>, which can be very large. Even though the data is effectively <span class="math inline">\(n\)</span>-dimensional, an embedding into an <span class="math inline">\((n+1)\)</span>-D array of side length <span class="math inline">\(N+1\)</span> has size <span class="math inline">\((N+1)^{(n+1)}\)</span>, which may be mostly zeros but still consumes memory and processing time. For small <span class="math inline">\(n\)</span> and modest <span class="math inline">\(N\)</span>, this is fine (e.g.&nbsp;for <span class="math inline">\(n=2, N=100\)</span>, roughly 5151 points embedded in a <span class="math inline">\(101^3 \approx 1\,040,000\)</span> grid – manageable). But if <span class="math inline">\(n\)</span> or <span class="math inline">\(N\)</span> increase, the full-grid FFT becomes infeasible. Using a non-uniform FFT or a custom approach that only processes the <span class="math inline">\(M=\binom{N+n}{n}\)</span> actual points is more efficient in those cases. Note, however, that even <span class="math inline">\(M\)</span> itself can be huge for large <span class="math inline">\(n,N\)</span>. The Fourier transform will produce <span class="math inline">\(M\)</span> frequency coefficients to fully reconstruct <span class="math inline">\(f\)</span>, so the curse of dimensionality isn’t completely avoided – it’s just shifted to a smaller space when possible.</p></li>
<li><p><strong>FFT Complexity:</strong> A standard FFT on an array of size <span class="math inline">\(D\)</span> points is <span class="math inline">\(O(D \log D)\)</span>. In our context, <span class="math inline">\(D=(N+1)^{(n+1)}\)</span> if using the padded grid. This can far exceed <span class="math inline">\(M\)</span> (the number of actual data points). Non-uniform FFTs can bring the complexity closer to <span class="math inline">\(O(M \log M)\)</span> (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=While%20a%20naive%20application%20of,17">Non-uniform discrete Fourier transform - Wikipedia</a>) by not processing the zeros explicitly. Still, <span class="math inline">\(\log M\)</span> can be large, and constant factors in NUFFT algorithms are also significant (due to interpolation steps). If only a subset of frequency coefficients are needed (for example, you only care about low-frequency behavior), one could compute those selectively rather than the full transform. There are algorithms for partial DFT or compressive sensing techniques that recover the most significant Fourier coefficients from fewer computations, which might be applied if <span class="math inline">\(f(X)\)</span> is suspected to be sparse in frequency domain.</p></li>
<li><p><strong>Accuracy and Sampling Issues:</strong> If the dataset is only a random sample of the true function (and not values on a full grid), using Fourier to reconstruct the full function is essentially an interpolation problem. Fourier series interpolation requires the function to be well-behaved and sufficiently sampled to avoid aliasing. Random sampling does not guarantee that – there could be “gaps” in frequency space leading to aliasing or ill-conditioning in the reconstruction. One might need to impose smoothness assumptions or regularize the Fourier fit (for instance, truncate high-frequency components) to get a stable reconstruction. In practice, one might use least squares to fit a truncated Fourier series to the sampled data. This is computationally expensive if many basis functions are needed. Additionally, if the samples are noisy or <span class="math inline">\(f\)</span> has high-frequency features, the reconstruction might miss fine details. Ensuring the constraint in the analysis (by using the appropriate basis) at least confines the interpolation to the valid domain, but doesn’t by itself solve the sampling density issue.</p></li>
<li><p><strong>Boundary Effects and Periodicity:</strong> The DFT treats the input as periodic. When we artificially embed a simplex-shaped domain into a hyper-rectangular array, we’re assuming that <span class="math inline">\(f(X)\)</span> repeats outside the domain with the pattern given by the array. In our embedding we put zeros, which is a specific type of extension (periodic extension with zeros beyond the simplex). This can introduce high-frequency components if the “true” function on the simplex did not actually go to zero at the boundaries. For example, if <span class="math inline">\(f\)</span> at the edges of the domain (where one <span class="math inline">\(x_i\)</span> is N and the rest 0) is not zero, but we padded zeros just outside that edge, the FFT will interpret that as a sharp drop at the boundary, which translates into many high-frequency components (Gibbs phenomenon). Thus, the frequency spectrum might show artifacts due to the discontinuity at the domain boundary. To mitigate this, one could apply a smooth window that brings <span class="math inline">\(f\)</span> to zero at the boundaries of the domain before embedding (at the cost of distorting <span class="math inline">\(f\)</span> somewhat), or use the intrinsic basis approach (Fourier on the simplex) which better handles boundary conditions. This is a limitation to be aware of: the straightforward FFT approach might over-represent high-frequency content that’s not actually part of <span class="math inline">\(f\)</span>, but rather an artifact of the extension.</p></li>
<li><p><strong>Numerical Stability:</strong> When performing a multi-dimensional DFT on large datasets, numerical precision can be a concern. Summing up oscillating terms <span class="math inline">\(e^{-i k\cdot X}\)</span> can lead to cancellations. If <span class="math inline">\(f(X)\)</span> varies over a large dynamic range, its Fourier coefficients might be very small and sensitive to floating-point error. Using double precision (standard in NumPy) usually suffices, but very large <span class="math inline">\(N\)</span> could pose issues. The NUFFT algorithms also introduce interpolation error – they typically are approximate to a user-specified tolerance. One should check that increasing the precision or oversampling parameter in a NUFFT does not significantly change results, to ensure the transform is accurate.</p></li>
<li><p><strong>Interpretation of Results:</strong> A practical limitation is that interpreting the multi-dimensional frequency content is not always intuitive. In 1D, a peak at frequency <span class="math inline">\(k\)</span> means a sinusoidal pattern of that period. In <span class="math inline">\(n\)</span> dimensions with a constraint, a “frequency vector” <span class="math inline">\(\mathbf{k}\)</span> might be tricky to interpret: it corresponds to a plane wave <span class="math inline">\(e^{i\mathbf{k}\cdot \mathbf{x}}\)</span>, which in the constrained space could mean a combination of oscillations in several components at once. For example, a mode where <span class="math inline">\(k_0=1, k_1=-1, k_2=0,...,k_n=0\)</span> (satisfying <span class="math inline">\(1 + (-1) + 0 + \cdots + 0 = 0\)</span>) indicates that as <span class="math inline">\(x_0\)</span> increases and <span class="math inline">\(x_1\)</span> decreases (with others fixed), <span class="math inline">\(f\)</span> oscillates. In contrast, a mode where <span class="math inline">\(k_0=k_1=\cdots=k_n\)</span> (not orthogonal to the sum constraint) would purely be an overall phase shift and should not appear if we enforce the constraint (or it appears as a DC component that might relate to shifting the function by a constant). So one has to map frequency domain insights back to the original variables carefully. The constraint complicates this slightly, but once you get used to thinking in terms of one fewer degree of freedom, it becomes manageable.</p></li>
<li><p><strong>Scaling with N:</strong> If one tries to increase $N`, the domain size grows and so does the computational load. For very large <span class="math inline">\(N\)</span> (say hundreds or thousands) and moderate dimension, even storing the data or transform may be impossible. In such cases, one might look for theoretical simplifications (for instance, if <span class="math inline">\(f(X)\)</span> has known symmetries or can be factorized). If <span class="math inline">\(f\)</span> is sparse (mostly zero) or has low effective rank, techniques like compressive sensing might reconstruct it from fewer samples. But in the worst case, the method doesn’t circumvent the fact that a general function on the simplex of size <span class="math inline">\(N\)</span> requires <span class="math inline">\(\mathcal{O}(M)\)</span> parameters to describe, which is huge. Therefore, this approach is most powerful when <span class="math inline">\(f\)</span> has some <em>bandlimited</em> or smooth nature such that it can be approximated by a relatively small number of Fourier components. If <span class="math inline">\(f\)</span> is essentially random on each point with no smoothness, the Fourier transform will be nearly flat (no strong patterns), and attempting to reconstruct or find structure is futile.</p></li>
</ul>
<p>In conclusion, multi-dimensional DFT techniques can be successfully applied to functions on a constrained-sum domain, but one must carefully embed the constraint to get meaningful results. There are efficient algorithms (NUFFTs) to handle non-uniform grids (<a href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform#:~:text=While%20a%20naive%20application%20of,17">Non-uniform discrete Fourier transform - Wikipedia</a>) and even research-grade FFTs on simplices (<a href="https://journal.global-sci.org/intro/article_detail.html?journal=undefined&amp;article_id=8754#:~:text=In%20this%20paper%20we%20propose,The%20relationship%20between">Multivariate Fourier Transform Methods over Simplex and Super-Simplex Domains</a>), which help with performance. Still, the exponential growth of complexity with dimension and the need for adequate sampling are key limitations. For moderate problem sizes where the structure of <span class="math inline">\(f\)</span> warrants it, the Fourier approach provides a powerful lens to examine periodic interactions and to reconstruct the function efficiently. Just keep in mind the trade-offs in complexity and the assumptions (like periodic extension) inherent in using DFTs when drawing conclusions from the frequency domain.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>